@page
@model Ogur.Sentinel.Api.Pages.RespawnModel
@{
    ViewData["Title"] = "Respawn Settings";
}

@if (Model.IsViewer)
{
    <div class="alert alert-info">
        👁️ You are viewing in <strong>read-only mode</strong>. Contact admin to make changes.
    </div>
}

<div class="main-block card">
    <h1>🔔 Respawn Settings</h1>

    <div id="loading" class="alert alert-info">Loading settings...</div>
    <div id="error" class="alert alert-danger d-none"></div>
    <div id="success" class="alert alert-success d-none">✓ Settings saved successfully!</div>

    <div id="settings-form" class="d-none">
        <form id="respawnForm">
            <div class="row">
                <div class="col-md-6">
                    <h4 class="title-gradient">⚙️ Timer Configuration</h4>

                    <div class="mb-3">
                        <label for="baseTime" class="form-label">Base Time (HH:MM:SS)</label>
                        <input type="text" class="form-control" id="baseTime" placeholder="01:10:30"
                               pattern="\d{2}:\d{2}:\d{2}" required>
                        <small class="text-muted">Starting time for respawn alignment</small>
                    </div>

                    <div class="mb-3">
                        <div class="glass p-3">
                            <div class="form-check form-switch mb-2">
                                <input class="form-check-input" type="checkbox" id="useSyncedTime">
                                <label class="form-check-label" for="useSyncedTime">
                                    <strong>🌐 Use time from wiki (Akademia)</strong>
                                </label>
                            </div>
                            <div id="syncedTimeInfo" class="mt-2 d-none">
                                <small class="text-muted">Synced time: <code id="syncedTime" class="ok">-</code></small><br>
                                <small class="text-muted">Last sync: <span id="lastSync">-</span></small>
                            </div>
                            <button type="button" class="btn btn-sm btn-outline-primary mt-2" onclick="manualSync()">
                                🔄 Sync now
                            </button>
                        </div>
                    </div>

                    <div class="mb-3">
                        <label for="leadSeconds" class="form-label">Lead Seconds</label>
                        <input type="number" class="form-control" id="leadSeconds" min="0" max="300" required>
                        <small class="text-muted">Play sound X seconds before actual respawn</small>
                    </div>

                    <div class="mb-3">
                        <label class="form-label">Voice Channels</label>
                        <div id="channelsList"></div>
                        <button type="button" class="btn btn-sm btn-outline-primary mt-2" onclick="addChannel()">+ Add
                            Channel
                        </button>
                    </div>
                </div>

                <div class="col-md-6">
                    <h4 class="title-gradient">🔊 Status</h4>

                    <div class="glass p-3 mb-3">
                        <div class="mb-3">
                            <div class="form-check form-switch">
                                <input class="form-check-input" type="checkbox" id="enabled10m">
                                <label class="form-check-label" for="enabled10m">
                                    <strong class="ok">10-minute respawns</strong>
                                </label>
                            </div>
                        </div>

                        <div class="mb-0">
                            <div class="form-check form-switch">
                                <input class="form-check-input" type="checkbox" id="enabled2h">
                                <label class="form-check-label" for="enabled2h">
                                    <strong class="ok">2-hour respawns</strong>
                                </label>
                            </div>
                        </div>
                    </div>

                    <div class="glass p-3">
                        <h5 class="muted">⏰ Next Triggers:</h5>
                        <div class="mb-2">
                            <span class="pill">
                                <span>10m:</span>
                                <strong id="next10m" class="ok">-</strong>
                            </span>
                        </div>
                        <div>
                            <span class="pill">
                                <span>2h:</span>
                                <strong id="next2h" class="ok">-</strong>
                            </span>
                        </div>
                    </div>


                    <div id="sound-upload-section" class="d-none mt-3">
                        <h5 class="title-gradient">🔊 Custom Sounds</h5>

                        <!-- 10-minute Sound -->
                        <div class="glass p-3 mb-3">
                            <h6 class="muted">10-minute Sound</h6>

                            <!-- Repeat settings dla 10m -->
                            <div class="d-flex gap-2 align-items-end mb-2">
                                <div style="flex: 0 0 100px;">
                                    <label for="repeat-plays-10m" class="form-label small mb-1">Plays</label>
                                    <input type="number" class="form-control form-control-sm"
                                           id="repeat-plays-10m" min="1" max="10" value="3">
                                </div>
                                <div style="flex: 0 0 120px;">
                                    <label for="repeat-gap-ms-10m" class="form-label small mb-1">Gap (ms)</label>
                                    <input type="number" class="form-control form-control-sm"
                                           id="repeat-gap-ms-10m" min="0" max="5000" value="1000">
                                </div>
                            </div>

                            <div class="d-flex gap-2 mb-2">
                                <button type="button" class="btn btn-sm btn-outline-primary flex-fill"
                                        onclick="playSound('10m', false)">
                                    ▶️ Once
                                </button>
                                <button type="button" class="btn btn-sm btn-outline-primary flex-fill"
                                        onclick="playSound('10m', true)">
                                    🔁 Loop
                                </button>
                            </div>
                            <input type="file" class="form-control form-control-sm mb-2" id="file-10m" accept=".wav">
                            <button type="button" class="btn btn-sm btn-primary w-100" onclick="uploadSound('10m')">
                                📤 Upload
                            </button>
                        </div>

                        <!-- 2-hour Sound -->
                        <div class="glass p-3">
                            <h6 class="muted">2-hour Sound</h6>

                            <!-- Repeat settings dla 2h -->
                            <div class="d-flex gap-2 align-items-end mb-2">
                                <div style="flex: 0 0 100px;">
                                    <label for="repeat-plays-2h" class="form-label small mb-1">Plays</label>
                                    <input type="number" class="form-control form-control-sm"
                                           id="repeat-plays-2h" min="1" max="10" value="3">
                                </div>
                                <div style="flex: 0 0 120px;">
                                    <label for="repeat-gap-ms-2h" class="form-label small mb-1">Gap (ms)</label>
                                    <input type="number" class="form-control form-control-sm"
                                           id="repeat-gap-ms-2h" min="0" max="5000" value="1000">
                                </div>
                            </div>

                            <div class="d-flex gap-2 mb-2">
                                <button type="button" class="btn btn-sm btn-outline-primary flex-fill"
                                        onclick="playSound('2h', false)">
                                    ▶️ Once
                                </button>
                                <button type="button" class="btn btn-sm btn-outline-primary flex-fill"
                                        onclick="playSound('2h', true)">
                                    🔁 Loop
                                </button>
                            </div>
                            <input type="file" class="form-control form-control-sm mb-2" id="file-2h" accept=".wav">
                            <button type="button" class="btn btn-sm btn-primary w-100" onclick="uploadSound('2h')">
                                📤 Upload
                            </button>
                        </div>
                    </div>

                </div>
            </div>


            <div class="d-grid gap-2 d-md-flex justify-content-md-end mt-4">
                <button type="button" id="reloadBtn" class="btn" onclick="reloadWithFeedback(event)">🔄 Reload</button>
                <button type="button" id="recalculateBtn" class="btn btn-secondary"
                        onclick="recalculateWithFeedback(event)">🔄 Recalculate Next
                </button>
                <button type="submit" id="saveBtn" class="btn btn-primary">💾 Save Settings</button>
            </div>
        </form>
    </div>
</div>
<div class="modal fade" id="addChannelModal" tabindex="-1">
    <div class="modal-dialog modal-dialog-scrollable">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Select Voice Channels</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div id="voiceChannelsList">
                    <div class="text-center">
                        <div class="spinner-border spinner-border-sm" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                        <p class="text-muted mt-2">Loading channels...</p>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <!-- ✅ Zmienione na confirmAddChannels() -->
                <button type="button" class="btn btn-primary" id="confirmAddChannels" onclick="confirmAddChannels()">
                    Add Selected
                </button>
            </div>
        </div>
    </div>
</div>

@section Scripts {
    <script>
        const IS_VIEWER = @(Model.IsViewer ? "true" : "false");
        let currentChannels = [];
        let maxChannels = 3;
        let availableVoiceChannels = [];
        let selectedChannelsForAdd = new Set();


        // Helper function for button feedback
        function showButtonFeedback(button, successText, duration = 2000) {
            const originalText = button.innerHTML;
            const originalDisabled = button.disabled;

            button.disabled = true;
            button.innerHTML = successText;

            setTimeout(() => {
                button.innerHTML = originalText;
                button.disabled = originalDisabled;
            }, duration);
        }

        function disableIfViewer(elementId) {
            if (IS_VIEWER) {
                const el = document.getElementById(elementId);
                if (el) el.disabled = true;
            }
        }

        async function loadSettings() {
            document.getElementById('loading').classList.remove('d-none');
            document.getElementById('error').classList.add('d-none');
            document.getElementById('success').classList.add('d-none');

            try {
                const response = await fetch('/settings');
                const data = await response.json();

                document.getElementById('baseTime').value = data.base_hhmm;
                document.getElementById('leadSeconds').value = data.lead_seconds;
                document.getElementById('enabled10m').checked = data.enabled_10m;
                document.getElementById('enabled2h').checked = data.enabled_2h;

                //document.getElementById('repeat-plays').value = data.repeat_plays || 3;
                //document.getElementById('repeat-gap-ms').value = data.repeat_gap_ms || 1000;
                document.getElementById('repeat-plays-10m').value = data.repeat_plays_10m || 3;
                document.getElementById('repeat-gap-ms-10m').value = data.repeat_gap_ms_10m || 1000;

                document.getElementById('repeat-plays-2h').value = data.repeat_plays_2h || 3;
                document.getElementById('repeat-gap-ms-2h').value = data.repeat_gap_ms_2h || 1000;


                // Wiki sync settings
                document.getElementById('useSyncedTime').checked = data.use_synced_time || false;
                if (data.synced_base_time) {
                    document.getElementById('syncedTime').textContent = data.synced_base_time;
                    document.getElementById('lastSync').textContent = data.last_sync_at
                        ? new Date(data.last_sync_at).toLocaleString()
                        : 'Never';
                    document.getElementById('syncedTimeInfo').classList.remove('d-none');
                }

                currentChannels = (data.channels || []).map(ch => String(ch));

                window.channelNames = {};
                window.availableVoiceChannels = [];

                try {

                    const channelsResp = await fetch('/channels/info', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({
                            channel_ids: currentChannels
                        })
                    });

                    if (channelsResp.ok) {
                        const channelsData = await channelsResp.json();
                        console.log('📥 /channels/info response:', channelsData);
                        console.log('📥 First channel ID from response:', channelsData[0]?.id, typeof channelsData[0]?.id);
                        console.log('📥 Current channels we sent:', currentChannels);

                        if (Array.isArray(channelsData)) {
                            channelsData.forEach(ch => {
                                const idAsString = String(ch.id);
                                console.log(`  Mapping: "${ch.id}" (${typeof ch.id}) → "${idAsString}"`);
                                window.channelNames[idAsString] = {name: ch.name, guild: ch.guild};
                            });
                        }
}
                    

                } catch (e) {
                    console.warn('Failed to load /channels/info:', e);
                }

                try {
                    // Próbuj załadować kanały głosowe
                    const voiceChannelsResp = await fetch('/channels/voice');
                    if (voiceChannelsResp.ok) {
                        const voiceChannelsData = await voiceChannelsResp.json();
                        window.availableVoiceChannels = voiceChannelsData.channels || [];

                        // Zaktualizuj channelNames o kanały głosowe (jeśli ich tam nie ma)
                        window.availableVoiceChannels.forEach(ch => {
                            const id = String(ch.id);
                            if (!window.channelNames[id]) {
                                window.channelNames[id] = {
                                    name: ch.name,
                                    guild: ch.guildName || ch.guild
                                };
                            }
                        });
                    }
                } catch (e) {
                    console.warn('Failed to load /channels/voice:', e);
                }

                renderChannels();

                // Load next triggers
                const nextResp = await fetch('/respawn/next');
                const nextData = await nextResp.json();

                // Load limits
                try {
                    const limitsResp = await fetch('/settings/limits');
                    if (limitsResp.ok) {
                        const limitsData = await limitsResp.json();
                        if (!limitsData.error) {
                            maxChannels = limitsData.max_channels;

                            const label = document.querySelector('label[for="channelsList"]')
                                || document.querySelector('.form-label');
                            if (label && label.textContent.includes('Voice Channels')) {
                                label.textContent = `Voice Channels (max ${maxChannels})`;
                            }
                        }
                    }
                } catch (e) {
                    console.warn('Failed to load limits, using default:', e);
                }

                document.getElementById('next10m').textContent = new Date(nextData.next10m).toLocaleString();
                document.getElementById('next2h').textContent = new Date(nextData.next2h).toLocaleString();

                document.getElementById('loading').classList.add('d-none');
                document.getElementById('settings-form').classList.remove('d-none');

                // Disable kontrolki dla viewer
                if (IS_VIEWER) {
                    disableIfViewer('baseTime');
                    disableIfViewer('leadSeconds');
                    disableIfViewer('useSyncedTime');
                    disableIfViewer('repeat-plays-10m');
                    disableIfViewer('repeat-gap-ms-10m');
                    disableIfViewer('repeat-plays-2h');
                    disableIfViewer('repeat-gap-ms-2h');
                    disableIfViewer('repeat-plays');
                    disableIfViewer('repeat-gap-ms');
                    disableIfViewer('saveBtn');
                    disableIfViewer('recalculateBtn');

                    // Ukryj przyciski akcji
                    document.querySelectorAll('button[onclick*="addChannel"], button[onclick*="manualSync"]').forEach(btn => {
                        btn.disabled = true;
                        btn.style.opacity = '0.5';
                    });

                    // Ukryj przyciski usuwania kanałów
                    document.querySelectorAll('.btn-close').forEach(btn => btn.style.display = 'none');

                    document.querySelectorAll('button[onclick*="playSound"]').forEach(btn => {
                        btn.disabled = true;
                        btn.style.opacity = '0.5';
                    });

                    document.querySelectorAll('button[onclick*="saveRepeatSettings"]').forEach(btn => {
                        btn.disabled = true;
                        btn.style.opacity = '0.5';
                    });

                    document.querySelectorAll('button[onclick*="uploadSound"]').forEach(btn => {
                        btn.disabled = true;
                        btn.style.opacity = '0.5';
                    });

                    // Disable file inputs
                    document.querySelectorAll('input[type="file"]').forEach(input => {
                        input.disabled = true;
                        input.style.opacity = '0.5';
                    });
                }
            } catch (error) {
                document.getElementById('loading').classList.add('d-none');
                document.getElementById('error').textContent = 'Failed to load settings: ' + error.message;
                document.getElementById('error').classList.remove('d-none');
            }
        }

        function renderChannels() {
            const container = document.getElementById('channelsList');
            container.innerHTML = '';
            if (currentChannels.length === 0) {
                container.innerHTML = '<p class="text-muted">No channels configured</p>';
                return;
            }
            currentChannels.forEach((ch) => {
                const info = window.channelNames?.[ch];
                const displayName = info ? `#${info.name}` : `#Channel`;
                const displayId = `<code style="color: var(--muted); font-size: 0.75em;">${ch}</code>`;
                const pill = document.createElement('span');
                pill.className = 'pill me-2 mb-2 d-inline-flex align-items-center';
                const closeBtn = IS_VIEWER ? '' : `
            <button class="btn-close btn-close-white ms-2" type="button" 
                    style="font-size: 0.7em; opacity: 0.7;" 
                    aria-label="Remove"></button>
        `;
                pill.innerHTML = `
            <span style="color: var(--accent);">${displayName}</span>
            <span class="ms-2">${displayId}</span>
            ${closeBtn}
        `;

                // ✅ Dodaj event listener tutaj, nie inline
                if (!IS_VIEWER) {
                    const btn = pill.querySelector('.btn-close');
                    if (btn) {
                        btn.addEventListener('click', () => removeChannel(ch));
                    }
                }

                container.appendChild(pill);
            });
        }

        function removeChannel(channelId) {
            if (IS_VIEWER) return;
            currentChannels = currentChannels.filter(id => id !== channelId);
            renderChannels();
        }

        async function addChannel() {
            if (IS_VIEWER) return;

            selectedChannelsForAdd.clear();

            const modal = new bootstrap.Modal(document.getElementById('addChannelModal'));
            modal.show();

            // Jeśli kanały są już załadowane, użyj ich, w przeciwnym razie załaduj ponownie
            if (!window.availableVoiceChannels || window.availableVoiceChannels.length === 0) {
                await loadVoiceChannels();
            } else {
                // Użyj już załadowanych kanałów
                renderVoiceChannelsList(window.availableVoiceChannels);
            }
        }

        async function loadVoiceChannels() {
            const list = document.getElementById('voiceChannelsList');
            list.innerHTML = '<div class="text-center"><div class="spinner-border spinner-border-sm"></div> Loading...</div>';

            try {
                const response = await fetch('/channels/voice');
                const data = await response.json();

                availableVoiceChannels = data.channels || [];
                renderVoiceChannelsList(availableVoiceChannels);
            } catch (error) {
                list.innerHTML = '<div class="text-danger">Failed to load channels</div>';
            }
        }

        function renderVoiceChannelsList(channels) {
            const list = document.getElementById('voiceChannelsList');
            list.innerHTML = '';

            if (channels.length === 0) {
                list.innerHTML = '<div class="text-muted text-center py-3">No voice channels found</div>';
                return;
            }

            const alreadyAdded = new Set(currentChannels);

            // Grupuj kanały po kategoriach
            const byCategory = {};
            channels.forEach(ch => {
                const category = ch.categoryName || 'Uncategorized';
                if (!byCategory[category]) {
                    byCategory[category] = [];
                }
                byCategory[category].push(ch);
            });

            // Renderuj każdą kategorię
            Object.entries(byCategory).forEach(([categoryName, categoryChannels]) => {
                // Nagłówek kategorii - używamy twojej klasy .category-header
                const categoryHeader = document.createElement('div');
                categoryHeader.className = 'category-header';

                // Dodaj emoji dla niektórych kategorii
                let displayName = categoryName;
                if (categoryName.toLowerCase().includes('lider')) {
                    displayName = `🏆 ${categoryName}`;
                } else if (categoryName.toLowerCase().includes('glevia')) {
                    displayName = `⭐ ${categoryName} ⭐`;
                }

                categoryHeader.textContent = displayName;
                list.appendChild(categoryHeader);

                // Kanały w kategorii - używamy twoich klas
                categoryChannels.forEach(ch => {
                    const channelId = String(ch.id);
                    const isAlreadyAdded = alreadyAdded.has(channelId);

                    const item = document.createElement('div');
                    item.className = `channel-list-item ${isAlreadyAdded ? 'disabled' : ''}`;

                    // Badge z liczbą użytkowników
                    const userBadge = ch.userCount > 0
                        ? `<span class="badge bg-success ms-1" style="font-size: 0.7rem;">${ch.userCount} 👤</span>`
                        : '';

                    // Badge "Already added"
                    const alreadyAddedBadge = isAlreadyAdded
                        ? '<span class="badge bg-secondary ms-1" style="font-size: 0.7rem;">Already added</span>'
                        : '';

                    item.innerHTML = `
                <input class="channel-checkbox" type="checkbox" value="${channelId}" 
                       id="ch_${channelId}" ${isAlreadyAdded ? 'disabled' : ''}>
                <label class="channel-label" for="ch_${channelId}">
                    <div class="channel-info">
                        <span style="font-size: 1.1rem;">🔊</span>
                        <span class="channel-name">${ch.name}</span>
                        ${userBadge}
                        ${alreadyAddedBadge}
                    </div>
                    <span class="channel-id">${channelId}</span>
                </label>
            `;

                    if (!isAlreadyAdded) {
                        const checkbox = item.querySelector('input');
                        checkbox.addEventListener('change', (e) => {
                            if (e.target.checked) {
                                selectedChannelsForAdd.add(channelId);
                            } else {
                                selectedChannelsForAdd.delete(channelId);
                            }
                            updateAddButtonState();
                        });
                    }

                    list.appendChild(item);
                });
            });

            updateAddButtonState();
        }

        function updateAddButtonState() {
            const btn = document.getElementById('confirmAddChannels');
            const textSpan = document.getElementById('addButtonText');

            if (!btn) {
                console.warn('⚠️ confirmAddChannels button not found!');
                return;
            }

            const count = selectedChannelsForAdd.size;
            const wouldExceedLimit = currentChannels.length + count > maxChannels;

            btn.disabled = count === 0 || wouldExceedLimit;

            let text;
            if (wouldExceedLimit) {
                text = `Cannot add (max ${maxChannels})`;

                // Pokaż alert w modalu
                let alert = document.querySelector('#voiceChannelsList .alert');
                if (!alert) {
                    alert = document.createElement('div');
                    alert.className = 'alert mb-3';
                    alert.innerHTML = `⚠️ Maximum ${maxChannels} channels allowed. Remove some channels first.`;
                    document.getElementById('voiceChannelsList').prepend(alert);
                }
            } else {
                // Usuń alert jeśli istnieje
                const alert = document.querySelector('#voiceChannelsList .alert');
                if (alert) alert.remove();

                if (count > 0) {
                    text = `Add ${count} channel${count > 1 ? 's' : ''}`;
                } else {
                    text = 'Select channels';
                }
            }

            if (textSpan) {
                textSpan.textContent = text;
            } else {
                btn.textContent = text;
            }
}

        function confirmAddChannels() {
            if (IS_VIEWER) return;

            selectedChannelsForAdd.forEach(channelId => {
                if (!currentChannels.includes(channelId)) {
                    currentChannels.push(channelId);
                }
            });

            renderChannels();

            const modal = bootstrap.Modal.getInstance(document.getElementById('addChannelModal'));
            modal.hide();

            selectedChannelsForAdd.clear();
        }

        async function recalculateWithFeedback(e) {
            if (IS_VIEWER) {
                alert('You have read-only access');
                return;
            }

            const btn = e.target;
            const originalText = btn.innerHTML;

            btn.disabled = true;
            btn.innerHTML = '⏳ Recalculating...';

            try {
                const response = await fetch('/respawn/recalculate', {method: 'POST'});
                if (response.ok) {
                    btn.innerHTML = '✓ Done!';

                    setTimeout(() => {
                        btn.innerHTML = originalText;
                        btn.disabled = false;
                    }, 2000);

                    setTimeout(() => loadSettings(), 500);
                } else {
                    throw new Error('Recalculate failed');
                }
            } catch (error) {
                btn.innerHTML = originalText;
                btn.disabled = false;
                alert('Failed to recalculate: ' + error.message);
            }
        }

        async function manualSync() {
            if (IS_VIEWER) {
                alert('You have read-only access');
                return;
            }

            const btn = event.target;
            const originalText = btn.innerHTML;

            btn.disabled = true;
            btn.innerHTML = '⏳ Syncing with Wiki...';

            try {
                const response = await fetch('/respawn/sync', {method: 'POST'});
                if (response.ok) {
                    const data = await response.json();

                    btn.innerHTML = '✓ Synced!';

                    document.getElementById('syncedTime').textContent = data.synced_base_time;
                    document.getElementById('lastSync').textContent = new Date(data.last_sync_at).toLocaleString();
                    document.getElementById('syncedTimeInfo').classList.remove('d-none');

                    setTimeout(() => {
                        btn.innerHTML = originalText;
                        btn.disabled = false;
                    }, 2000);

                    if (document.getElementById('useSyncedTime').checked) {
                        await recalculateWithFeedback({target: document.getElementById('recalculateBtn')});
                    }
                } else {
                    throw new Error('Sync failed');
                }
            } catch (error) {
                btn.innerHTML = originalText;
                btn.disabled = false;
                alert('Failed to sync: ' + error.message);
            }
        }

        async function playSound(soundType, useSettings = false) {
            if (IS_VIEWER) {
                alert('You have read-only access');
                return;
            }

            try {
                const response = await fetch(`/respawn/test-sound?sound=${soundType}&use_settings=${useSettings}`, {
                    method: 'POST'
                });

                if (response.ok) {
                    console.log('Sound played successfully');
                } else {
                    const error = await response.json();
                    alert('Failed to play sound: ' + (error.error || 'Unknown error'));
                }
            } catch (error) {
                alert('Failed to play sound: ' + error.message);
            }
        }

        async function saveRepeatSettings() {
            if (IS_VIEWER) return;

            const payload = {
                repeat_plays_10m: parseInt(document.getElementById('repeat-plays-10m').value),
                repeat_gap_ms_10m: parseInt(document.getElementById('repeat-gap-ms-10m').value),
                repeat_plays_2h: parseInt(document.getElementById('repeat-plays-2h').value),
                repeat_gap_ms_2h: parseInt(document.getElementById('repeat-gap-ms-2h').value)
            };

            try {
                const response = await fetch('/settings', {
                    method: 'PATCH',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(payload)
                });

                if (!response.ok) throw new Error('Save failed');

                console.log('✓ Repeat settings saved');
            } catch (error) {
                console.error('Failed to save repeat settings:', error);
                alert('Failed to save: ' + error.message);
            }
}
        

        async function uploadSound(soundType) {
            if (IS_VIEWER) {
                alert('You have read-only access');
                return;
            }

            const fileInput = document.getElementById(`file-${soundType}`);
            const file = fileInput.files[0];

            if (!file) {
                alert('Please select a file first');
                return;
            }

            const btn = event.target;
            const originalText = btn.innerHTML;

            btn.disabled = true;
            btn.innerHTML = '⏳ Uploading...';

            try {
                const formData = new FormData();
                formData.append('file', file);
                formData.append('sound_type', soundType);

                const response = await fetch('/sounds/upload', {
                    method: 'POST',
                    body: formData
                });

                if (response.ok) {
                    btn.innerHTML = '✓ Uploaded!';
                    fileInput.value = '';

                    setTimeout(() => {
                        btn.innerHTML = originalText;
                        btn.disabled = IS_VIEWER;
                    }, 2000);
                } else {
                    const error = await response.json();
                    throw new Error(error.error || 'Upload failed');
                }
            } catch (error) {
                alert('Upload failed: ' + error.message);
                btn.innerHTML = originalText;
                btn.disabled = IS_VIEWER;
            }


        }


        document.getElementById('respawnForm').addEventListener('submit', async (e) => {
            e.preventDefault();

            if (IS_VIEWER) {
                alert('You have read-only access. Contact admin to make changes.');
                return;
            }

            const saveBtn = document.getElementById('saveBtn');
            const originalText = saveBtn.innerHTML;

            saveBtn.disabled = true;
            saveBtn.innerHTML = '💾 Saving...';

            const payload = {
                base_hhmm: document.getElementById('baseTime').value,
                lead_seconds: parseInt(document.getElementById('leadSeconds').value),
                channels: currentChannels,
                roles_allowed: [],
                use_synced_time: document.getElementById('useSyncedTime').checked
            };

            console.log('Sending payload:', payload);

            try {
                const response = await fetch('/settings', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(payload)
                });

                if (response.ok) {
                    saveBtn.innerHTML = '✓ Saved!';
                    document.getElementById('success').classList.remove('d-none');
                    setTimeout(() => document.getElementById('success').classList.add('d-none'), 3000);

                    setTimeout(() => {
                        saveBtn.innerHTML = originalText;
                        saveBtn.disabled = false;
                    }, 2000);

                    setTimeout(() => loadSettings(), 500);
                } else {
                    throw new Error('Save failed');
                }
            } catch (error) {
                saveBtn.innerHTML = originalText;
                saveBtn.disabled = false;

                document.getElementById('error').textContent = 'Failed to save: ' + error.message;
                document.getElementById('error').classList.remove('d-none');
            }
        });

        // Toggle handlers
        document.getElementById('enabled10m').addEventListener('change', async (e) => {
            if (IS_VIEWER) {
                e.target.checked = !e.target.checked;
                alert('You have read-only access');
                return;
            }

            const checkbox = e.target;
            const originalState = checkbox.checked;

            try {
                const response = await fetch('/respawn/toggle', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        enable10m: checkbox.checked,
                        enable2h: null
                    })
                });

                if (!response.ok) throw new Error('Toggle failed');

                const label = checkbox.nextElementSibling;
                const originalText = label.innerHTML;
                label.innerHTML = '<strong class="ok">✓ Updated!</strong>';
                setTimeout(() => label.innerHTML = originalText, 2000);

            } catch (error) {
                console.error('Toggle 10m failed:', error);
                checkbox.checked = !originalState;
                alert('Failed to toggle 10m respawns');
            }
        });

        document.getElementById('enabled2h').addEventListener('change', async (e) => {
            if (IS_VIEWER) {
                e.target.checked = !e.target.checked;
                alert('You have read-only access');
                return;
            }

            const checkbox = e.target;
            const originalState = checkbox.checked;

            try {
                const response = await fetch('/respawn/toggle', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        enable10m: null,
                        enable2h: checkbox.checked
                    })
                });

                if (!response.ok) throw new Error('Toggle failed');

                const label = checkbox.nextElementSibling;
                const originalText = label.innerHTML;
                label.innerHTML = '<strong class="ok">✓ Updated!</strong>';
                setTimeout(() => label.innerHTML = originalText, 2000);

            } catch (error) {
                console.error('Toggle 2h failed:', error);
                checkbox.checked = !originalState;
                alert('Failed to toggle 2h respawns');
            }
        });

        document.getElementById('useSyncedTime').addEventListener('change', async (e) => {
            if (IS_VIEWER) {
                e.target.checked = !e.target.checked;
                alert('You have read-only access');
                return;
            }

            const checkbox = e.target;
            const originalState = checkbox.checked;

            const payload = {
                base_hhmm: document.getElementById('baseTime').value,
                lead_seconds: parseInt(document.getElementById('leadSeconds').value),
                channels: currentChannels,
                roles_allowed: [],
                use_synced_time: checkbox.checked
            };

            try {
                const response = await fetch('/settings', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(payload)
                });

                if (!response.ok) throw new Error('Toggle sync failed');

                const label = checkbox.nextElementSibling;
                const originalText = label.innerHTML;
                label.innerHTML = '<strong class="ok">✓ Updated!</strong>';
                setTimeout(() => label.innerHTML = originalText, 2000);

                await recalculateWithFeedback({target: document.getElementById('recalculateBtn')});
            } catch (error) {
                console.error('Toggle sync failed:', error);
                checkbox.checked = originalState;
                alert('Failed to toggle wiki sync');
            }
        });

        document.getElementById('sound-upload-section').classList.remove('d-none');

        ['repeat-plays-10m', 'repeat-gap-ms-10m', 'repeat-plays-2h', 'repeat-gap-ms-2h'].forEach(id => {
            document.getElementById(id).addEventListener('change', async (e) => {
                if (IS_VIEWER) {
                    e.target.value = e.target.defaultValue;
                    return;
                }

                await saveRepeatSettings();
            });
        });
        
        loadSettings();
    </script>
}